#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
The MIT License (MIT)

Copyright (c) 2013, Gentaro Muramatsu

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
"""
"""
convert MIB to HTML
===================

Architecture
------------
MIB definition file ==(smidump)==> Input formatXML ==(*this tool*)==> HTML

Output format can be configured by changing template file.
i.e. template engine is used for the last stage.
tenjin and jinja2 are candidates.



XML format
----------
http://www.ibr.cs.tu-bs.de/projects/nmrg/smi.xsd

Software Design
---------------

1. Read xml with xml.etree module
2. scan the data and build index
   - root node 
   - name - oid mapping and vise versa
   - shortened name

3. pass the XML tree and the index to a template engine

mib structure
-------------
(module)
    (identity) <- root node name
(imports)*
(typedefs)*
(nodes)*
    node
    { name, oid, status }
    scalar
        access
        description

(notifications)*
(groups)*
(compliances)*
"""

from xml.etree import ElementTree as et

import jinja_filter
from util import *


# functions

def read_mib_xml(filename):
    """Read XML generated by smidump and return XML DOM tree
    return ElementTree:

    exceptions:
        IOError
    """
    return et.parse(filename)

# preprocess functions for mib xml

def build_index(dom):
    """parse index table for all elements having oid attribute

    1. build cross reference for oid and node name

    input:
        dom: ElementTree
    return:
        dict
            mib_name: (oid,Element)
            oid: (mib_name,Element)
    """
    result = {}
    for node in dom.iterfind(".//*[@oid]"):
        oid = node.get("oid")
        name = node.get("name")
        # result[oid] = (name,node)
        result[name] = (oid,node)

    # add Textual Convention name with dummy oid
    for node in dom.iterfind("typedefs/typedef"):
        name = node.get("name")
        result[name] = (u"0",node)

    for node in dom.iterfind(u"imports/import"):
        # exclude standard SMIv2 imports
        if node.get(u"module") not in [u"SNMPv2-SMI", u"SNMPv2-TC"]:
            name = node.get(u"name")
            result[name] = (u"0",node)

    return result

def build_mib_node_array(dom):
    """Build sorted array of oid nodes 
    input:
        dom: ElementTree
    result:
        array of (oid(tuple), node) sorted by oid
    """
    mib_array = []
    for node in dom.iterfind(".//*[@oid]"):
        oid = node.get("oid")
        tag = node.tag

        if tag not in ["row", "column"]:
            # exclude table content
            mib_array.append( (oid_str2tuple(oid), node) )

    mib_array.sort(cmp= lambda x,y: cmp( x[0], y[0] ))
    return mib_array


def build_tree_index(dom,root):
    """build index for tree drawing
    input:
        dom: (ElementTree)
        root: root oid to calculate base level (string)
    result:
        (rootlevel,treeindex) : (integer, dict)
        treeindex: (tuple) -> (integer)
    """
    rootlevel = oidlen(root) - 1
    ttree = {}
    for node in dom.iterfind(".//*[@oid]"):
        oid = node.get("oid")
        toid = oid_str2tuple(oid)
        curlevel = len( toid )
        for lvl in xrange(rootlevel, curlevel):
            key = toid[rootlevel-1:lvl] 
            if ttree.has_key(key):
                ttree[key] = max( ttree[key], toid[lvl] )
            else:
                ttree[key] = toid[lvl]
            # print "{}.{} [{}:{}]/ {} = {}".format( toid, curlevel, rootlevel - 1, lvl, toid[rootlevel-1:lvl], toid[lvl])
    return (rootlevel, ttree)


def find_identity(dom,index):
    """find identity name
    return identity name

    input:
        dom: mib (ElementTree)
        index: mib index generated by build_index (dict)
    exceptions:
        InvalidMibError

    module/identity[@node] : name of root node
    """
    identity = dom.find("./module/identity[@node]")
    if identity is None:
        raise InvalidMibError("identity")

    identityName = identity.get("node")
    if identityName not in index:
        raise InvalidMibError("identity[@node]")

    return identityName

# prepare template

'''
filters/functions can use same context as template by decorating with contextfilter/contextfunction
'''

def prepare_context(mib, opts):
    """Build context dict for rendering

        mib : XML data read from MIB
        opts: commandline options (Namespace object generated by argparse)
    """

    # build various indicies from mib(xml ElementTree)
    mib_index = build_index(mib)
    mib_array = build_mib_node_array(mib)

    identity_name = find_identity(mib, mib_index)
    identity_oid  = mib_index[identity_name][0]

    root_oid  = ".".join( [str(i) for i in mib_array[0][0] ]) if opts.fromTop else identity_oid
    root_oidlist = root_oid.split(u".")
    
    # adjust root level
    if opts.rootShiftLevel > 0:
        root_oidlist = root_oidlist[:-opts.rootShiftLevel]

    root_oid = u".".join(root_oidlist)
    root_oid_prefix = u".".join(root_oidlist[:-1]) + u"."

    oid_prefix_level, ttree = build_tree_index(mib, root_oid)


    return {
            u"mib": mib,             # ElementTree
            u"root": root_oid,       # string
            u"identity": identity_oid,       # string
            u"identity_name": identity_name, # string
            u"index": mib_index,     # string -> (string{oid}, Element{node} )
            u"tree_index": ttree,
            u"oid_prefix_level": oid_prefix_level,
            u"mib_array": mib_array,
            u"root_oid_prefix": root_oid_prefix,
            u"root_oid_prefix_len": len(root_oid_prefix),
            }

def build_argparser():
    """build parser for commandline argument.

       This function use 'argparse' standard module introduced from python v2.7
    """
    import argparse

    def _positiveInt(s):
        """Accept positive interger values only"""

        v = int(s)
        if v < 0:
            raise argparse.ArgumentTypeError( "{} is not a positive integer.".format(s))
        return v

    parser = argparse.ArgumentParser(description='Generate HTML document from MIB(SMIv2) definition')

    parser.add_argument('mibxml', help='MIB file or XML file(converted by smidump)')
    parser.add_argument('-k', dest="forceMibParse", help='continue conversion forcely even when MIB error is detected (smidump option)', action='store_true')
    parser.add_argument('-r', dest="fromTop", help='set top oid as oid abbreviation root. Default root is identity oid', action='store_true' );
    parser.add_argument('-D', dest="templateException", help='change behavior for undefined object in templates (For template debugging only)', choices=['normal', 'debug', 'strict' ])
    parser.add_argument('-s', metavar="root_level_offset", dest="rootShiftLevel", help='offset of root oid level (default: 0)', type=_positiveInt, default=0 );
    return parser


def mib2xmlpipe( mibfile, force=False ):
    """Convert MIB file to XML and returns file handle

        Return None in case of conversion failure.
    """
    ENV_MIB2XML = "mib2xml"
    CMD_MIB2XML = "smidump"

    # get smidump command name

    import os, subprocess, shlex
    command = os.environ[ENV_MIB2XML] if os.environ.has_key(ENV_MIB2XML) else CMD_MIB2XML
    command += " -f xml "
    if force:
        command += "-k "
    command_line = shlex.split( command )
    command_line.append(mibfile)

    try:
        return subprocess.Popen( command_line, stdout=subprocess.PIPE )

    except OSError:
        return None

def callwithxml( filename, callback, force=False ):
    """Prepare XML file handle for parser.
        Just open the specified file when XML is directly given.
        Otherwise, try conversion from MIB to XML.

        callback function must take 1 argument, and accept file object and file name.

        return: return type of the callback function
        dependency: environment variable MIB2XMLTOOL override default 'smidump'.
    """

    mibp = None

    if not filename.endswith( ".xml" ):
        # assume given file is MIB
        mibp = mib2xmlpipe(filename, force)
        if mibp != None:
            try:
                return callback( mibp.stdout )
            finally:
                mibp.poll()

    return callback( filename )

def isEtree13Installed():
    "Check if proper version of ElementTree library is installed"

    from distutils.version import StrictVersion

    if StrictVersion(et.VERSION) < StrictVersion('1.3.0'):
        return False

    return True

def main():

    import sys
    import textwrap
    import jinja2

    # import submodule
    from jinja_filter import prepare_filters

    if not isEtree13Installed():
        print >> sys.stderr, textwrap.dedent( """\
        Error: ELementTree library is older than expected.

        ElementTree 1.3 or newer, which is accompanied with Python 2.7,
        is required.
        """ )
        return 31


    parser = build_argparser()
    options = parser.parse_args()

    # We don't have to take error cases into account
    # because parse_args aborts program execution with error messages.
    # when given command line options are inappropriate

    filename = options.mibxml

    try:
        mib = callwithxml( filename, read_mib_xml, force=options.forceMibParse)
        # mib = read_mib_xml(filename)
    except (IOError):
        print >> sys.stderr, "Failed to open XML file: {}".format(filename)
        return 1

    except et.ParseError as e:
        print >> sys.stderr, textwrap.dedent( """\
        Parse Error : {}
        This tool accept MIB file or xml-formatted MIB file translated from MIB(SMI) file.

        Confirm if smidump command is in the search path
        or explicitly specified by "mib2xml" environment variable
        if you specified MIB file.

        Confirm if specified file is valid XML format
        compatible with smidump output
        if you specified xml file.

        smidump command is available as a part of libsmi
        http://www.ibr.cs.tu-bs.de/projects/libsmi/
        """ ).format(e.message)
        return 3

    try:
        # prepare
        undefinedPolicy = jinja2.Undefined
        if options.templateException == "strict":
            undefinedPolicy = jinja2.StrictUndefined
        elif options.templateException == "debug":
            undefinedPolicy = jinja2.DebugUndefined

        template_env = jinja2.Environment(autoescape=True,
                loader=jinja2.PackageLoader(__name__, package_path=""),
                undefined=undefinedPolicy)
        for key, func in prepare_filters().iteritems():
            template_env.filters[ key ] = func

        template = template_env.get_template("template.html")
        print template.render(**(prepare_context(mib, options)) )

    except InvalidMibError as e :
        print >> sys.stderr, "MIB XML is invalid: {}".format(e.message)
        return 5

    return 0
    
if __name__ == '__main__':
    sys.exit( main())
