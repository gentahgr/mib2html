#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
convert MIB to HTML
===================

Architecture
------------
MIB definition file ==(smidump)==> Input formatXML ==(*this tool*)==> HTML

Output format can be configured by changing template file.
i.e. template engine is used for the last stage.
tenjin and jinja2 are candidates.



XML format
----------
http://www.ibr.cs.tu-bs.de/projects/nmrg/smi.xsd

Software Design
---------------

1. Read xml with xml.etree module
2. scan the data and build index
   - root node 
   - name - oid mapping and vise versa
   - shortened name

3. pass the XML tree and the index to a template engine

mib structure
-------------
(module)
    (identity) <- root node name
(imports)*
(typedefs)*
(nodes)*
    node
    { name, oid, status }
    scalar
        access
        description

(notifications)*
(groups)*
(compliances)*
"""

from xml.etree import ElementTree as et
import sys

# Common exception

class InvalidMibError(RuntimeError):
    pass


# functions

def read_mib_xml(filename):
    """Read XML generated by smidump and return XML DOM tree
    return ElementTree:

    exceptions:
        IOError
    """
    return et.parse(filename)

def oid_str2tuple(oid_str):
    """convert oid (dot-separated number sequence) to tuple
    input:
        oid (BaseString)
    return:
        oid (tuple)
    exceptions:
        ValueError (non-numeric character is in oid_str)
    """
    return tuple( int(n) for n in oid_str.split(".") )

def oidlen(oid_str):
    return oid_str.count(".") + 1

# preprocess functions for mib xml

def build_index(dom):
    """parse index table for all elements having oid attribute

    1. build cross reference for oid and node name
    2. build supplemental info for tree structure
       

    input:
        dom: ElementTree
    return:
        dict
            mib_name: (oid,Element)
            oid: (mib_name,Element)
    """
    result = {}
    for node in dom.iterfind(".//*[@oid]"):
        oid = node.get("oid")
        name = node.get("name")
        result[oid] = (name,node)
        result[name] = (oid,node)

    return result

def build_tree_index(dom,root):
    """build index for tree drawing
    input:
        dom: (ElementTree)
        root: root oid to calculate base level (string)
    result:
        (rootlevel,treeindex) : (integer, dict)
        treeindex: (tuple) -> (integer)
    """
    rootlevel = oidlen(root) - 1
    ttree = {}
    for node in dom.iterfind(".//*[@oid]"):
        oid = node.get("oid")
        toid = oid_str2tuple(oid)
        curlevel = len( toid )
        for lvl in xrange(rootlevel, curlevel):
            ttree[ toid[rootlevel-1:lvl] ] = toid[lvl]
            # print "{}.{} [{}:{}]/ {} = {}".format( toid, curlevel, rootlevel - 1, lvl, toid[rootlevel-1:lvl], toid[lvl])
    return (rootlevel, ttree)


def find_root(dom,index):
    """find base oid
    return root node oid

    input:
        dom: mib (ElementTree)
        index: mib index generated by build_index (dict)
    exceptions:
        InvalidMibError

    module/identity[@node] : name of root node
    """
    identity = dom.find("./module/identity[@node]")
    if identity is None:
        raise InvalidMibError("identity")

    identityName = identity.get("node")
    if identityName not in index:
        raise InvalidMibError("identity[@node]")

    return index[identityName]

# prepare template

# jinja filter functions
class TagString(object):
    def __init__(self, string, tag_type=None, param=None):
        self.string = string
        self.tag_type = tag_type
        self.param = param

    def __unicode__(self):
        return self.string

    def __repr__(self):
        return "TagString: {}/{}/{}".format(self.string,self.tag_type,self.param)

def generate_format_syntax(root_name):


    def is_local(mod_name):
        return mod_name == root_name

    def format_syntax(node):
        """create string expression of syntax (mib data type)
        input:

         node: an Element which as "syntax" child element
        return:
            list of TagString
        """
        syntag = node.find("syntax")
        if syntag is None:
            # ignore gracefully
            return ''

        result = []
        typetag = syntag[0]
        if typetag.tag == "type":
            # type
            mod_name = typetag.get("module")
            name = typetag.get("name")
            if is_local(mod_name):
                result.append( TagString(name,"typedef",mod_name))
            else:
                result.append( TagString(name,"import",mod_name))
        elif typetag.tag == "typedef":
            basetype = typetag.get("basetype")
            if basetype == "Enumeration":
                result.append( TagString( u"/ ".join(
                    [ u"{}({})".format( num.get("name"), num.get("number")) for num in typetag.iterfind("namednumber") ]
                    )))

            elif basetype == "Bits":
                result.append( TagString( u"| ".join(
                    [ u"{}({})".format( num.get("name"), num.get("number")) for num in typetag.iterfind("namednumber") ]
                    )))
            else:
                parent = typetag.find("parent")
                if parent is None:
                    result.append(TagString(basetype))
                else:
                    basetype = parent.get("name")
                    mod_name = parent.get("module")
                    if is_local(mod_name):
                       result.append(TagString(basetype,"typedef",mod_name))
                    else:
                       result.append(TagString(basetype,"import",mod_name))
                ranges = typetag.findall("range")
                if ranges:
                    result.append( TagString( u" (" ))
                    result.append( TagString( u", ".join(
                        [ "{} .. {}".format(r.get("min"),r.get("max")) for r in ranges ]
                    )))
                    result.append( TagString( u")" ))
        else:
            raise InvalidMibError("syntax for {} has no type or typedef node".format(node.get("name")))

        return u"".join(r.string for r in result)
        # return result
    return format_syntax

def generate_calc_oid_indent(dom, rootOid):
    """generator for indent level calculation
    input:
        rootOid: oid for root node (string)
    return:
        a function for oid calculation
    """
    # oid_prefix_level = oidlen(rootOid) - 1
    oid_prefix_level, ttree = build_tree_index(dom, rootOid)

    def calc_oid_indent(oid_str):
        """calculate in dent depth and tree structure info
        input:
            oid_str: oid string
        return:
            a list of flags
            example:
              [0,1,1,0,2]
                0: vertical line through the cell
                1: no line
                2: vertical line through the cell (with horizontal line)
                3: vertical line to the cell (with horizontal line)
        """
        oid = oid_str2tuple(oid_str)
        cur_level= len(oid)
        result = []
        for depth in xrange(oid_prefix_level, cur_level):
            val = oid[depth]
            pattern = 0 if ttree[ oid[oid_prefix_level-1:depth] ] > val else 1
            pattern += 0 if depth + 1 < cur_level else 2
            result.append( pattern )
            # print >>sys.stderr, "d={}, ttree{} = {}, v = {} -> {}".format(
            #        depth, oid[oid_prefix_level-1:depth], ttree[ oid[oid_prefix_level-1:depth] ], val, pattern )
        return result
    return calc_oid_indent

def generate_short_oid(rootOid):
    """generator for short oid expression

    example:
       root: 1.3.6.9.9
       1.3.6.9.9.1.2.3.4 -> ..(9).1.2.3.4

    input:
        rootOid: oid for root node (string)
    return:
        a function to shorten oid
    """
    root_oidlist = rootOid.split(u".")[:-1]
    root_oid_prefix = u".".join(root_oidlist) + "."
    oid_prefix_len = len(root_oidlist)

    def short_oid(oid_str):
        "shorten oid string"
        if oid_str.startswith(root_oid_prefix):
            oid_list = oid_str.split(u".")[oid_prefix_len:]
            return u"..({}).".format(oid_list[0]) + u".".join(oid_list[1:])

    return short_oid

def format_description(desc_str):
    """Format description in SMIv2 MIB file for HTML output
    input:
        desc_str: description string (unicode_str)
    return:
        unicode string including <p> tag
    """
    return desc_str

import jinja2
if __name__ == '__main__':
    def main():
        import sys
        if len(sys.argv) < 2:
            print >> sys.stderr, "usage: {} mib_xml.xml".format( sys.argv[0] )
            return 2
        filename = sys.argv[1]

        try:
            mib = read_mib_xml(filename)
        except (IOError):
            print >> sys.stderr, "Failed to open XML file: {}".format(filename)
            return 1

        try:
            # prepare
            mib_index = build_index(mib)
            root_oid, root_node = find_root(mib,mib_index)

            template_env = jinja2.Environment(autoescape=True,loader=jinja2.FileSystemLoader("."))
            template_env.filters["format_syntax"] = generate_format_syntax(root_node)
            template_env.filters["calc_indent"] = generate_calc_oid_indent(mib, root_oid)
            template_env.filters["short_oid"] = generate_short_oid(root_oid)
            template_env.filters["format_desc"] = format_description

            template = template_env.get_template("template.html")
            print template.render(mib=mib,index=mib_index,root=root_oid)

        except InvalidMibError as e :
            print >> sys.stderr, "MIB XML is invalid: {}".format(e.message)


        
    main()
