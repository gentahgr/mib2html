#!/usr/bin/python
"""
convert MIB to HTML
===================

Architecture
------------
MIB definition file ==(smidump)==> Input formatXML ==(*this tool*)==> HTML

Output format can be configured by changing template file.
i.e. template engine is used for the last stage.
tenjin and jinja2 are candidates.



XML format
----------
http://www.ibr.cs.tu-bs.de/projects/nmrg/smi.xsd

Software Design
---------------

1. Read xml with xml.etree module
2. scan the data and build index
   - root node 
   - name - oid mapping and vise versa
   - shortened name

3. pass the XML tree and the index to a template engine

mib structure
-------------
(module)
    (identity) <- root node name
(imports)*
(typedefs)*
(nodes)*
    node
    { name, oid, status }
    scalar
        access
        description

(notifications)*
(groups)*
(compliances)*
"""

from xml.etree import ElementTree as et

# Common exception

class InvalidMibError(RuntimeError):
    pass


# functions

def read_mib_xml(filename):
    """Read XML generated by smidump and return XML DOM tree
    return ElementTree:

    exceptions:
        IOError
    """
    return et.parse(filename)

def oid_str2tuple(oid_str):
    """convert oid (dot-separated number sequence) to tuple
    input:
        oid (BaseString)
    return:
        oid (tuple)
    exceptions:
        ValueError (non-numeric character is in oid_str)
    """
    return tuple( int(n) for n in oid_str.split(".") )

def oidlen(oid_str):
    return oid_str.count(".") + 1

# preprocess functions for mib xml

def build_index(dom):
    """parse index table for all elements having oid attribute
    input:
        dom: ElementTree
    return:
        dict
            mib_name: (oid,Element)
            oid: (mib_name,Element)
    """
    result = {}
    for node in dom.iterfind(".//*[@oid]"):
        oid = node.get("oid")
        name = node.get("name")
        result[oid] = (name,node)
        result[name] = (oid,node)

    return result


def find_root_oid(dom,index):
    """find base oid
    return root node oid

    input:
        dom: mib (ElementTree)
        index: mib index generated by build_index (dict)
    exceptions:
        InvalidMibError

    module/identity[@node] : name of root node
    """
    identity = dom.find("./module/identity[@node]")
    if identity is None:
        raise InvalidMibError("identity")

    identityName = identity.get("node")
    if identityName not in index:
        raise InvalidMibError("identity[@node]")

    (rootOid,root) = index[identityName]
    return rootOid

# prepare template

# jinja filter functions
def format_syntax(node):
    """create string expression of syntax (mib data type)
    input:
        node: an Element which as "syntax" child element
    return:
        unicode_string
    """
    pass

def generate_calc_oid_indent(rootOid):
    """generator for indent level calculation
    input:
        rootOid: oid for root node (string)
    return:
        a function for oid calculation
    """

    def calc_oid_indent(oid_str):
        """calculate indent depth
        input:
            oid_str: oid string
        return:
            indent level
        """
        return 1

    return calc_oid_indent

def format_description(desc_str):
    """Format description in SMIv2 MIB file for HTML output
    input:
        desc_str: description string (unicode_str)
    return:
        unicode string including <p> tag
    """
    return desc_str

import jinja2
if __name__ == '__main__':
    def main():
        import sys
        if len(sys.argv) < 2:
            print >> sys.stderr, "usage: {} mib_xml.xml".format( sys.argv[0] )
            return 2
        filename = sys.argv[1]

        try:
            mib = read_mib_xml(filename)
        except (IOError):
            print >> sys.stderr, "Failed to open XML file: {}".format(filename)
            return 1

        try:
            # prepare
            mib_index = build_index(mib)
            root_oid = find_root_oid(mib,mib_index)

            template_env = jinja2.Environment(autoescape=True,loader=jinja2.FileSystemLoader("."))
            template_env.filters["format_syntax"] = format_syntax
            template_env.filters["calc_indent"] = generate_calc_oid_indent(root_oid)
            template_env.filters["format_desc"] = format_description

            template = template_env.get_template("template.html")
            print template.render(mib=mib,index=mib_index,root=root_oid)

        except InvalidMibError as e :
            print >> sys.stderr, "MIB XML is invalid: {}".format(e.message)


        
    main()
